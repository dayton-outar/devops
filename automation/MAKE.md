# GNU Make Cheat Sheet

## **Basics**

- **Makefile**: The file that contains rules for building the project.
- **Target**: A file that needs to be created or updated.
- **Prerequisites**: Files needed to create/update the target.
- **Recipe**: The commands to execute to build the target.

### General Structure

```make
target: prerequisites
    recipe
```

- Lines starting with `#` are comments.
- Commands in recipes are indented with a **TAB**, not spaces.

### How `make` Processes a Makefile

`make` is a powerful build automation tool commonly used in software development to manage prerequisites and automate the compilation of programs. It works by reading instructions from a file called a **Makefile**, which defines how to build a project, specifying targets, prerequisites, and commands to execute.

When `make` is run, it follows a series of logical steps to process the Makefile:

#### 1. **Read the Makefile**
`make` first looks for a file named **Makefile** or **makefile** in the current directory. If found, it reads the file and interprets its contents. The Makefile typically consists of:
   - **Targets**: These represent the final products or files you want to build (e.g., an executable or object files).
   - **Prerequisites**: Files that are required for building the target (e.g., source code files or header files).
   - **Commands**: Shell commands to run in order to generate the target from its prerequisites.

For example:
```makefile
target: prerequisite1 prerequisite2
    command-to-generate-target
```

#### 2. **Identify the Default Target**
The first target in the Makefile is usually considered the **default target**, which is built if no target is explicitly specified when invoking `make`. This is typically the final executable or a combination of tasks.

#### 3. **Check Prerequisites**
Once a target is identified, `make` checks whether the target needs to be rebuilt by comparing the timestamps of the target and its prerequisites. If any prerequisite has a newer timestamp than the target, `make` considers the target "out-of-date" and rebuilds it.

#### 4. **Recurse Through Prerequisites**
If the target depends on other files that themselves are generated by other rules in the Makefile, `make` recurses through these prerequisites. It processes each prerequisite in turn, ensuring that they are up to date before attempting to build the main target.

#### 5. **Execute Commands**
Once `make` determines that a target needs to be built, it executes the shell commands listed in the Makefile to generate the target. These commands typically involve invoking a compiler or some other tool to create the required output. If a command fails (i.e., returns a non-zero exit status), `make` will stop execution unless explicitly instructed to continue.

For example:
```makefile
my_program: main.o helper.o
    gcc -o my_program main.o helper.o
```
In this case, `make` first checks the prerequisites (`main.o` and `helper.o`) and then runs the `gcc` command if necessary.

#### 6. **Build Targets and Exit**
After processing the prerequisites and running the commands, `make` either successfully builds the target or exits with an error if something went wrong. If the target is up to date and no rebuild is needed, `make` simply exits without performing any actions.

### Conclusion
`make` simplifies and automates the process of building programs by intelligently managing prerequisites and invoking necessary commands. It processes a Makefile by reading target-prerequisite relationships, checking timestamps, and executing commands to keep projects organized, efficient, and consistent during the build process.

---

## **Common Commands**

- **`make`**: Default command, runs the first target in the Makefile.
- **`make target`**: Runs a specific target.
- **`make -f filename`**: Use a different file instead of the default `Makefile`.
- **`make -n`**: Show commands without running them.
- **`make -k`**: Continue building even if errors occur.
- **`make -j [jobs]`**: Run multiple jobs in parallel.

See [How to Run `make`](https://www.gnu.org/software/make/manual/html_node/Running.html)

---

## **Variables**

Variables store values you can reuse.

```make
CC = gcc
CFLAGS = -Wall -g

program: program.o
    $(CC) $(CFLAGS) -o program program.o
```

To substitute a variable’s value, write a dollar sign followed by the name of the variable in parentheses or braces: either `$(foo)` or `${foo}` is a valid reference to the variable `foo`.

#### Variable Assignment

- **`=`**: Simple assignment (evaluates when used).
- **`:=`**: Immediate assignment (evaluates when defined).
- **`?=`**: Safe assignment.
- **`+=`**: Appends to the variable's value.
- **`!=`**: Perform shell command and assign return value.
---

### **Automatic Variables**

- **$@**: Represents the target name. The target of the rule.
- **$<**: First prerequisite.
- **$?**: Prerequisites newer than the target.
- **$^**: All prerequisites.
- **$\***: The stem of the target's filename without suffix.
- **\$+**: Like `$^` (all prerequisites), but preserves duplicates and order.
- **$|**: The names of all the order-only prerequisites.
- **$(@D)**: The directory part of the target file's name.

---

### Environment Variables

You can use environment variables within a Makefile. For example, setting `CC=gcc` in the environment overrides `CC` in the Makefile unless `?=` (conditional assignment) is used:

```make
CC ?= gcc
```

In `make`, environment variables allow flexibility when configuring the build process. Below is a list of common environment variables used in `make`, along with their default values and examples of how to use them.

---

#### 1. **CC**: Compiler
   - **Description**: Specifies which C compiler to use.
   - **Default Value**: `gcc`
   - **Use**: Change the compiler dynamically.
   - **Example**:
     ```bash
     make CC=clang
     ```
     Inside Makefile:
     ```makefile
     $(CC) -o my_program main.c
     ```

#### 2. **CFLAGS**: Compiler Flags
   - **Description**: Specifies options or flags that should be passed to the compiler for C programs.
   - **Default Value**: None (empty string)
   - **Use**: Set custom compiler flags.
   - **Example**:
     ```bash
     make CFLAGS="-O2 -Wall"
     ```
     Inside Makefile:
     ```makefile
     $(CC) $(CFLAGS) -o my_program main.c
     ```

#### 3. **CPPFLAGS**: Preprocessor Flags
   - **Description**: Flags passed to the C preprocessor (used for including directories or defining macros).
   - **Default Value**: None (empty string)
   - **Use**: Define include directories or macros.
   - **Example**:
     ```bash
     make CPPFLAGS="-I/usr/local/include"
     ```
     Inside Makefile:
     ```makefile
     $(CC) $(CPPFLAGS) -o my_program main.c
     ```

#### 4. **LDFLAGS**: Linker Flags
   - **Description**: Flags passed to the linker to specify libraries or library paths during linking.
   - **Default Value**: None (empty string)
   - **Use**: Provide additional flags for the linker.
   - **Example**:
     ```bash
     make LDFLAGS="-L/usr/local/lib"
     ```
     Inside Makefile:
     ```makefile
     $(CC) $(LDFLAGS) -o my_program main.o
     ```

#### 5. **LDLIBS**: Libraries
   - **Description**: Specifies additional libraries to link with, typically used in conjunction with `LDFLAGS`.
   - **Default Value**: None (empty string)
   - **Use**: Link against specific libraries.
   - **Example**:
     ```bash
     make LDLIBS="-lm"
     ```
     Inside Makefile:
     ```makefile
     $(CC) $(LDFLAGS) $(LDLIBS) -o my_program main.o
     ```

#### 6. **MAKEFLAGS**: Make Options
   - **Description**: Specifies options for `make` itself, like running in parallel mode or setting verbosity.
   - **Default Value**: None (empty string, unless options are passed via command line)
   - **Use**: Pass global `make` options.
   - **Example**:
     ```bash
     make MAKEFLAGS="-j4"
     ```
     Inside Makefile (optional):
     ```makefile
     $(MAKEFLAGS)
     ```

#### 7. **SHELL**: Shell for Commands
   - **Description**: Specifies the shell to use for executing commands.
   - **Default Value**: `/bin/sh` (on Unix-like systems)
   - **Use**: Change the shell used by `make`.
   - **Example**:
     ```bash
     make SHELL=/bin/bash
     ```
     Inside Makefile:
     ```makefile
     SHELL := /bin/bash
     ```

#### 8. **DESTDIR**: Installation Directory
   - **Description**: Specifies a directory where files should be staged before installation, often used when packaging software.
   - **Default Value**: None (empty string)
   - **Use**: Specify a staging directory for installing files.
   - **Example**:
     ```bash
     make install DESTDIR=/tmp/staging
     ```
     Inside Makefile:
     ```makefile
     install:
         cp my_program $(DESTDIR)/usr/local/bin/
     ```

#### 9. **PREFIX**: Installation Prefix
   - **Description**: Specifies the base directory for installation paths.
   - **Default Value**: `/usr/local`
   - **Use**: Set the base installation path.
   - **Example**:
     ```bash
     make install PREFIX=/home/user
     ```
     Inside Makefile:
     ```makefile
     install:
         cp my_program $(PREFIX)/bin/
     ```

#### 10. **VAR=value**: Custom Variables
   - **Description**: You can define custom variables to pass into the Makefile from the environment.
   - **Default Value**: None (empty string, unless explicitly set)
   - **Use**: Pass specific configuration values to the Makefile.
   - **Example**:
     ```bash
     make VAR=debug
     ```
     Inside Makefile:
     ```makefile
     ifeq ($(VAR),debug)
         CFLAGS += -g
     endif
     ```

---

A sample Makefile might look like this:

```makefile
CC = gcc
CFLAGS = -Wall -O2
LDFLAGS = -L/usr/local/lib
LDLIBS = -lm

my_program: main.o
    $(CC) $(CFLAGS) $(LDFLAGS) -o my_program main.o $(LDLIBS)

clean:
    rm -f *.o my_program
```

You can override the default values by running `make` with different environment variables:

```bash
make CC=clang CFLAGS="-g -Wall" LDFLAGS="-L/my/lib" LDLIBS="-lcustomlib"
```

### Special Variables

`make` supports some variables that have special properties.

#### 1. **`.RECIPEPREFIX`**
   - **Description**: Defines the character used as a prefix for recipe lines in the Makefile. By default, recipes are indented with a tab character, but `.RECIPEPREFIX` allows you to change this.
   - **Default Value**: Tab (`\t`)
   - **Use**: Change the recipe prefix to avoid issues with tab characters.
   - **Example**:
     ```makefile
     .RECIPEPREFIX = >
     
     all:
     >echo "Building..."
     >gcc -o my_program main.o
     ```
     In this case, the `>` character is used as the recipe prefix instead of a tab.

#### 2. **`.PHONY`**
   - **Description**: Specifies targets that are not actual files but are rather commands or actions. This prevents `make` from confusing a target with a file of the same name.
   - **Default Value**: Not applicable (you define which targets are phony).
   - **Use**: Use `.PHONY` to mark targets that don’t correspond to real files.
   - **Example**:
     ```makefile
     .PHONY: clean
     
     clean:
         rm -f *.o my_program
     ```
     In this example, `clean` is declared as a phony target, ensuring that `make` won’t mistake it for a file named `clean`.

#### 3. **`.SUFFIXES`**
   - **Description**: Controls the list of suffixes used in implicit rules. Implicit rules allow `make` to automatically infer how to build files from their suffixes (e.g., `.c` to `.o`).
   - **Default Value**: A predefined list of common suffixes like `.o`, `.c`, `.cpp`, etc.
   - **Use**: Modify or clear the list of suffixes that `make` uses for its built-in implicit rules.
   - **Example**:
     ```makefile
     .SUFFIXES: .c .o
     
     my_program: main.o
         gcc -o my_program main.o
     ```
     You can also clear all suffixes:
     ```makefile
     .SUFFIXES:
     ```

#### 4. **`.DEFAULT_GOAL`**
   - **Description**: Specifies the default target that `make` will attempt to build if no target is given on the command line. By default, this is the first target listed in the Makefile.
   - **Default Value**: The first target in the Makefile
   - **Use**: Explicitly set the default goal to be a specific target.
   - **Example**:
     ```makefile
     .DEFAULT_GOAL := all
     
     all: my_program
         @echo "Building all targets"
     
     clean:
         rm -f *.o my_program
     ```
     This sets `all` as the default goal, even if it’s not the first target.

#### 5. **`.FEATURES`**
   - **Description**: Contains a list of features that are enabled in the current version of `make`. This is a read-only variable and is useful for debugging and determining compatibility.
   - **Default Value**: Varies depending on the version of `make`
   - **Use**: View which features are available in the current build of `make`.
   - **Example**:
     ```makefile
     all:
         @echo "Make features: $(.FEATURES)"
     ```
     This prints the list of features enabled in your version of `make`.

#### 6. **`.PRECIOUS`**
   - **Description**: Prevents `make` from deleting intermediate files when a build process is interrupted (usually due to an error). By default, `make` may delete incomplete targets if the build fails.
   - **Default Value**: Not applicable (you specify which targets should be preserved).
   - **Use**: Mark targets that should not be deleted if `make` fails during the build.
   - **Example**:
     ```makefile
     .PRECIOUS: my_program
     
     my_program: main.o helper.o
         gcc -o my_program main.o helper.o
     ```
     If the build is interrupted, `my_program` will not be deleted.

#### 7. **`.INTERMEDIATE`**
   - **Description**: Marks files as intermediate files, which are generated during the build process and deleted when no longer needed. Typically used for temporary files like object files.
   - **Default Value**: Not applicable (you specify which files are intermediate).
   - **Use**: Define files that should be treated as temporary.
   - **Example**:
     ```makefile
     .INTERMEDIATE: main.o helper.o
     
     my_program: main.o helper.o
         gcc -o my_program main.o helper.o
     ```
     Here, `main.o` and `helper.o` will be treated as intermediate files and removed after the build is completed.

#### 8. **`.SECONDARY`**
   - **Description**: Similar to `.INTERMEDIATE`, but prevents intermediate files from being deleted after they are no longer needed. Useful if you want to keep temporary files for debugging.
   - **Default Value**: Not applicable (you specify the files).
   - **Use**: Preserve intermediate files without deleting them after the build process.
   - **Example**:
     ```makefile
     .SECONDARY: main.o helper.o
     
     my_program: main.o helper.o
         gcc -o my_program main.o helper.o
     ```
     In this case, `main.o` and `helper.o` are not deleted, even though they are intermediate.

#### 9. **`.DELETE_ON_ERROR`**
   - **Description**: If set, `make` deletes the target file if an error occurs during its creation. This prevents leaving incomplete or corrupted files when the build fails.
   - **Default Value**: Not enabled by default.
   - **Use**: Enable automatic deletion of files when their build fails.
   - **Example**:
     ```makefile
     .DELETE_ON_ERROR:
     
     my_program: main.o
         gcc -o my_program main.o
     ```
     If the `gcc` command fails, the `my_program` file will be deleted.

#### 10. **`.IGNORE`**
   - **Description**: Tells `make` to ignore errors in commands. This is equivalent to using `-` before individual commands, allowing the build to proceed even if some commands fail.
   - **Default Value**: Not set by default (you have to specify the targets to ignore errors for).
   - **Use**: Mark specific targets to ignore errors.
   - **Example**:
     ```makefile
     .IGNORE: clean
     
     clean:
         rm -f *.o my_program
     ```
     In this case, any error in the `clean` rule will be ignored.

#### 11. **`.EXPORT_ALL_VARIABLES`**
   - **Description**: If set, all variables defined in the Makefile are exported to child processes. Without this, only explicitly exported variables are passed to child processes.
   - **Default Value**: Not set by default.
   - **Use**: Export all variables without having to explicitly list them.
   - **Example**:
     ```makefile
     .EXPORT_ALL_VARIABLES:
     
     CC = gcc
     CFLAGS = -O2
     
     my_program: main.o
         $(CC) $(CFLAGS) -o my_program main.o
     ```

#### 12. **`.SILENT`**
   - **Description**: Suppresses the display of commands before they are executed. This is equivalent to prefixing individual commands with `@`.
   - **Default Value**: Not set by default.
   - **Use**: Make `make` run silently without showing commands.
   - **Example**:
     ```makefile
     .SILENT:
     
     all:
         echo "Building program..."
     ```

These special variables give `make` additional functionality and flexibility, allowing developers to have more control over how builds are structured, how errors are handled, and how intermediate files are managed.

---

## **Pattern Rules**
Pattern rules allow you to define a general rule for files with similar names.

```make
%.o: %.c
    cc -c $< -o $@
```

This means: for any `.c` file, create an object `.o` file.

Here’s an example of a **pattern rule** using **`$?`**:

### **Pattern Rule Example using `$?`**

```makefile
%.o: %.c
    gcc -c $< -o $@ $(CFLAGS) $(CPPFLAGS)

program: file1.o file2.o
    gcc -o program $^ $(LDFLAGS)

.PHONY: all
all: program

.PHONY: rebuild
rebuild: program
    @echo "Rebuilding changed files"
    gcc -o program $? $(LDFLAGS)
```

### **Explanation:**
- **`%.o: %.c`**: A pattern rule that says for any `.c` file, generate the corresponding `.o` file by compiling with `gcc`.
  - `$<` is the first prerequisite, i.e., the `.c` file.
  - `$@` is the target, i.e., the `.o` file.

- **`program: file1.o file2.o`**: This target builds the `program` executable from `file1.o` and `file2.o`.

- **`rebuild`**: This target rebuilds the program by compiling only the files that have changed.
  - `$?` represents the prerequisites that are **newer** than the target (in this case, the `.o` files that are newer than `program`).
  - This allows only the changed `.o` files to be recompiled when `rebuild` is called, rather than recompiling everything.

By using `$?`, this rule ensures only the changed files are recompiled, which is more efficient than recompiling everything.

Here's an example of a **pattern rule** using **`$^`**:

### **Pattern Rule Example using `$^`**

```makefile
%.o: %.c
    gcc -c $< -o $@ $(CFLAGS)

program: file1.o file2.o file3.o
    gcc -o program $^ $(LDFLAGS)

.PHONY: all
all: program
```

### **Explanation:**
- **`%.o: %.c`**: This pattern rule compiles each `.c` file into its corresponding `.o` object file.
  - **`$<`**: The first prerequisite (the `.c` file).
  - **`$@`**: The target (the `.o` file).

- **`program: file1.o file2.o file3.o`**: This rule links all the object files into the `program` executable.
  - **`$^`**: All prerequisites, which in this case are `file1.o`, `file2.o`, and `file3.o`.

In this example, `$^` is used in the `program` target to represent all object files (`file1.o file2.o file3.o`), which are passed to the `gcc` linker to build the final executable.

Here’s a list of the additional automatic variables in GNU Make, with short descriptions and explanations:

### **Additional Automatic Variables**

- **`$*`**:   
  **Explanation**: In a pattern rule like `%.o: %.c`, `$*` refers to the "stem" of the matched file, which is the filename without the extension (for example, `file` if the target is `file.o`).

  **Example**:
  ```makefile
  %.o: %.c
      gcc -c $< -o $*.o
  ```

- **`$+`**:  
  **Explanation**: Useful when you want to pass repeated or ordered prerequisites to the recipe (for example, when linking certain files multiple times).

  **Example**:
  ```makefile
  lib: obj1.o obj2.o obj1.o
      ar rcs lib.a $+
  ```

- **`$|`**:   
  **Explanation**: Order-only prerequisites are dependencies that must be built before the target, but do not cause the target to rebuild if they change.

  **Example**:
  ```makefile
  all: main.o | lib
      gcc -o all main.o lib.a
  ```

- **`$(@D)`**:   
  **Explanation**: If the target is `dir/file.o`, `$(@D)` would expand to `dir`. This is useful for making sure the directory exists before creating the target.

  **Example**:
  ```makefile
  $(OBJDIR)/%.o: %.c
      mkdir -p $(@D)
      gcc -c $< -o $@
  ```

These variables offer more control and flexibility in handling filenames, directories, and ordered dependencies in your Makefiles.

---

### **Command Prefixes**

- **`@`**:  
  **Description**: Suppresses the command echo.  
  **Example**:
  ```makefile
  all:
      @echo "Building the project"
  ```
  The `@` prevents `echo "Building the project"` from being printed to the terminal, so only the output (`Building the project`) is shown.

- **`-`**:  
  **Description**: Ignores errors from the command.  
  **Example**:
  ```makefile
  clean:
      -rm *.o
  ```
  The `-` makes Make ignore errors from the `rm` command, so it won't stop if some `.o` files don’t exist.

- **`+`**:  
  **Description**: Forces the command to be executed in a sub-shell, even if `make` is run without the `-j` (parallel) option.  
  **Example**:
  ```makefile
  all:
      +make -C subdir
  ```
  The `+` ensures that the command `make -C subdir` runs in a sub-shell.

- **`$(SHELL)`**:  
  **Description**: Executes the command with the current shell.  
  **Example**:
  ```makefile
  all:
      $(SHELL) -c "echo Hello, world!"
  ```
  This forces the command to be run in the shell specified by the `SHELL` variable.

---

## **Built-in Rules**

GNU `make` comes with built-in rules for common tasks. For example:
```make
.c.o:
    $(CC) $(CFLAGS) -c $< -o $@
```

- **`.c.o`**: Tells `make` how to convert `.c` to `.o` files.
- You can override or define your own rules if necessary.

Here’s a catalogue of some of the most commonly used built-in rules in `make`:

### 1. **Compiling C Programs (`.c -> .o`)**
   - **Rule**: Compiles a `.c` file into an object (`.o`) file.
   - **Command**:
     ```bash
     $(CC) $(CPPFLAGS) $(CFLAGS) -c -o $@ $<
     ```
   - **Use**:
     ```makefile
     %.o: %.c
     ```
   - **Example**:
     If you have a `main.c` file, you can build `main.o` without explicitly writing a rule:
     ```bash
     make main.o
     ```

### 2. **Linking C Programs (`.o -> executable`)**
   - **Rule**: Links object files into an executable.
   - **Command**:
     ```bash
     $(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@
     ```
   - **Use**:
     ```makefile
     my_program: main.o utils.o
     ```
   - **Example**:
     You can link `main.o` and `utils.o` into an executable:
     ```bash
     make my_program
     ```

### 3. **Compiling C++ Programs (`.cpp -> .o`)**
   - **Rule**: Compiles a `.cpp` file into an object (`.o`) file.
   - **Command**:
     ```bash
     $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c -o $@ $<
     ```
   - **Use**:
     ```makefile
     %.o: %.cpp
     ```
   - **Example**:
     If you have a `main.cpp` file, you can build `main.o`:
     ```bash
     make main.o
     ```

### 4. **Linking C++ Programs (`.o -> executable`)**
   - **Rule**: Links C++ object files into an executable.
   - **Command**:
     ```bash
     $(CXX) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@
     ```
   - **Use**:
     ```makefile
     my_program: main.o utils.o
     ```
   - **Example**:
     You can link `main.o` and `utils.o` (from C++ source files) into an executable:
     ```bash
     make my_program
     ```

### 5. **Compiling Fortran Programs (`.f -> .o`)**
   - **Rule**: Compiles a Fortran (`.f`) file into an object file.
   - **Command**:
     ```bash
     $(FC) $(FFLAGS) -c -o $@ $<
     ```
   - **Use**:
     ```makefile
     %.o: %.f
     ```
   - **Example**:
     Compile a Fortran file into an object:
     ```bash
     make main.o
     ```

### 6. **Linking Fortran Programs (`.o -> executable`)**
   - **Rule**: Links Fortran object files into an executable.
   - **Command**:
     ```bash
     $(FC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@
     ```
   - **Use**:
     ```makefile
     my_program: main.o utils.o
     ```
   - **Example**:
     You can link Fortran object files into an executable:
     ```bash
     make my_program
     ```

### 7. **Assembling Programs (`.s -> .o`)**
   - **Rule**: Assembles a `.s` (assembly) file into an object (`.o`) file.
   - **Command**:
     ```bash
     $(AS) $(ASFLAGS) -o $@ $<
     ```
   - **Use**:
     ```makefile
     %.o: %.s
     ```
   - **Example**:
     To assemble an assembly file into an object:
     ```bash
     make main.o
     ```

### 8. **Yacc/Bison to C (`.y -> .c`)**
   - **Rule**: Compiles a `.y` (Yacc or Bison) grammar file into a `.c` file.
   - **Command**:
     ```bash
     $(YACC) $(YFLAGS) $< -o $@
     ```
   - **Use**:
     ```makefile
     %.c: %.y
     ```
   - **Example**:
     To generate a C file from a Yacc grammar file:
     ```bash
     make parser.c
     ```

### 9. **Lex/Flex to C (`.l -> .c`)**
   - **Rule**: Compiles a `.l` (Lex or Flex) file into a `.c` file.
   - **Command**:
     ```bash
     $(LEX) $(LFLAGS) $< -o $@
     ```
   - **Use**:
     ```makefile
     %.c: %.l
     ```
   - **Example**:
     To generate a C file from a Lex file:
     ```bash
     make lexer.c
     ```

### 10. **Creating Static Libraries (`.a`) from Object Files**
   - **Rule**: Creates a static library (`.a` file) from object (`.o`) files.
   - **Command**:
     ```bash
     $(AR) $(ARFLAGS) $@ $^
     ```
   - **Use**:
     ```makefile
     libmylib.a: main.o utils.o
     ```
   - **Example**:
     To create a static library from object files:
     ```bash
     make libmylib.a
     ```

### 11. **Extracting Object Files from a Static Library (`.a -> .o`)**
   - **Rule**: Extracts object files from a static library.
   - **Command**:
     ```bash
     $(AR) x $<
     ```
   - **Use**:
     ```makefile
     %.o: libmylib.a
     ```

### 12. **Making `.tar.gz` Archives**
   - **Rule**: Creates a `.tar.gz` archive of files.
   - **Command**:
     ```bash
     tar -czf $@ $^
     ```
   - **Use**:
     ```makefile
     %.tar.gz: %
         tar -czf $@ $^
     ```
   - **Example**:
     To create a `.tar.gz` archive:
     ```bash
     make project.tar.gz
     ```

### 13. **Cleaning Object and Executable Files (`.o -> clean`)**
   - **Rule**: Cleans up `.o` files and executables, commonly used with the `clean` target.
   - **Command**:
     ```bash
     rm -f *.o my_program
     ```
   - **Use**:
     ```makefile
     clean:
         rm -f *.o my_program
     ```
   - **Example**:
     Clean up all the object and binary files:
     ```bash
     make clean
     ```

### 14. **Linking and Creating `.so` (Shared Library)**
   - **Rule**: Creates a shared library from object files (`.so`).
   - **Command**:
     ```bash
     $(CC) $(LDFLAGS) -shared -o $@ $^ $(LDLIBS)
     ```
   - **Use**:
     ```makefile
     %.so: %.o
     ```
   - **Example**:
     To create a shared library from an object file:
     ```bash
     make libmylib.so
     ```

### 15. **Making `.dvi` Documentation from LaTeX Files**
   - **Rule**: Compiles a LaTeX (`.tex`) file into a `.dvi` file.
   - **Command**:
     ```bash
     $(TEX) $<
     ```
   - **Use**:
     ```makefile
     %.dvi: %.tex
     ```
   - **Example**:
     To create `.dvi` documentation:
     ```bash
     make report.dvi
     ```

### 16. **Compiling Java Programs (`.java -> .class`)**
   - **Rule**: Compiles a `.java` file into a `.class` file.
   - **Command**:
     ```bash
     $(JAVAC) $(JFLAGS) -d $(@D) $<
     ```
   - **Use**:
     ```makefile
     %.class: %.java
     ```
   - **Example**:
     To compile a Java file into a class:
     ```bash
     make HelloWorld.class
     ```

### 17. **Linking Java Programs into a JAR (`.class -> .jar`)**
   - **Rule**: Links `.class` files into a JAR file.
   - **Command**:
     ```bash
    

---

## **Phony Targets**
Phony targets are not real files but just labels for running recipes.

```make
.PHONY: clean
clean:
    rm *.o
```

The `.PHONY` target prevents `make` from confusing the target name with actual file names.

---

## **Functions**
GNU `make` supports functions for manipulating text.

### Example Functions:

- **`$(wildcard pattern)`**: Returns files matching the pattern.
- **`$(patsubst pattern,replacement,text)`**: Replaces parts of a string.
- **`$(shell command)`**: Executes a shell command and returns the output.

See [GNU Make Functions](https://www.gnu.org/software/make/manual/html_node/Functions.html)

---

## **Conditional Parts**

You can make conditional statements in Makefiles using `ifeq`, `ifneq`, `ifdef`, and `ifndef`.

```make
ifeq ($(CC),gcc)
    CFLAGS = -O2
else
    CFLAGS = -g
endif
```

---

## **Dependency Management**
Dependencies are used to specify which files a target depends on.

```make
program: file1.o file2.o file3.o
    gcc -o program file1.o file2.o file3.o
```

If any `.o` file is newer than `program`, `make` rebuilds `program`.

### **Automatic Dependency Generation**

To automatically generate dependencies for C files:

```make
%.d: %.c
    $(CC) -M $< > $@
include $(wildcard *.d)
```

This generates `.d` files that contain the dependencies for `.c` files and includes them in the Makefile.

---

## **Suffix Rules (Deprecated in Modern Usage)**
Used for transforming files, suffix rules are older versions of pattern rules.

```make
.SUFFIXES: .c .o
.c.o:
    gcc -c $< -o $@
```

These are now generally replaced by pattern rules (`%.o: %.c`).

---

## **Recursive Make**
If you have subdirectories with separate Makefiles, you can use recursive `make`:

```make
subdir:
    $(MAKE) -C subdir
```

The `-C` option tells `make` to run in the subdirectory.

---

## **Error Handling**
To make `make` continue despite errors, use `-` before a command:

```make
clean:
    -rm *.o
```

---

## **Debugging**
- **`make -d`**: Debugging information.
- **`make -p`**: Print all variables and implicit rules.

---

This cheat sheet covers the essential commands, variables, and patterns you'll need to use GNU `make`. You can dive deeper into specific features or error handling by referring to the book.

## Further Reading

1. [GNU Make](https://www.gnu.org/software/make/manual/html_node/index.html)
1. [GNU Make: Quick Reference](https://www.gnu.org/software/make/manual/html_node/Quick-Reference.html)

## Videos

1. [Makefile-Related Videos](https://www.youtube.com/playlist?list=PL9IEJIKnBJjEPxenuhKU7J5smY4XjFnyg) - [Jacob Sorber](https://www.youtube.com/@JacobSorber)